<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>My Radio</title>
<meta name="description" content="Simple web player for my M3U radio playlists.">
<meta name="theme-color" content="#0b0f14">
<!-- SVG favicon -->
<link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect width='24' height='24' rx='5' fill='%230b0f14'/%3E%3Cpath d='M4 13a8 8 0 0 1 16 0' stroke='%235fb1ff' stroke-width='2'/%3E%3Crect x='3' y='13' width='4' height='7' rx='1' fill='%235fb1ff'/%3E%3Crect x='17' y='13' width='4' height='7' rx='1' fill='%235fb1ff'/%3E%3C/svg%3E" />
<style>
:root{--bg:#0b0f14;--bg-soft:#111824;--card:#0f1725;--text:#e6edf3;--muted:#aab6c3;--brand:#5fb1ff;--accent:#86efac;--border:#1f2937;--success:#10b981;--spinner:#5fb1ff}
@media(prefers-color-scheme:light){:root{--bg:#f7f9fc;--bg-soft:#ffffff;--card:#ffffff;--text:#0b0f14;--muted:#4b5563;--brand:#2563eb;--accent:#16a34a;--border:#e5e7eb;--success:#059669;--spinner:#2563eb}}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,helvetica neue,Noto Sans,Arial,apple color emoji,segoe ui emoji;color:var(--text);background:var(--bg)}
.topbar{position:fixed;top:0;left:0;right:0;z-index:10;display:flex;align-items:center;gap:12px;padding:12px 16px;background:var(--bg-soft);border-bottom:1px solid var(--border);backdrop-filter:saturate(1.2) blur(6px)}
.brand{font-weight:700;letter-spacing:.2px;color:var(--brand);user-select:none;text-decoration:none;display:inline-flex;align-items:center;gap:8px}
#searchInput{flex:1;appearance:none;border:1px solid var(--border);background:var(--card);color:var(--text);border-radius:10px;padding:10px 12px;outline:none}
#searchInput::placeholder{color:var(--muted)}
/* Wider main container to reduce left/right empty space */
#app{max-width:1600px;margin:70px auto 96px;padding:0 12px}
.loading,.empty,.error{color:var(--muted);text-align:center;padding:24px 12px}
.section-title{margin:16px 0 10px;font-weight:700;font-size:18px}
.playlist-meta{color:var(--muted);font-size:13px;margin-bottom:16px}
/* Wider, denser playlist grid on the home page */
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:16px; padding-bottom: 96px;}
.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;display:flex;flex-direction:column;gap:6px;transition:transform .08s ease,border-color .08s ease;text-decoration:none;color:inherit}
.card:hover{transform:translateY(-1px);border-color:#2b3a50}
.card .title{display:block;font-weight:600;color:var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
.card .meta{color:var(--muted);font-size:13px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}

/* Sub-pages station list: responsive columns (3 on desktop, scaling down to 1 on mobile) */
.stations{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;margin:0;padding:0;list-style:none; padding-bottom: 96px;}
@media (min-width: 1200px) { .stations { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
@media (min-width: 900px) and (max-width: 1199px) { .stations { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
@media (max-width: 640px){ .stations{grid-template-columns:1fr} }

.station{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px 12px;display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:10px;cursor:pointer}
.station:focus{outline:2px solid var(--brand);outline-offset:2px}
.station .play{font-size:18px;width:40px;height:40px;border-radius:10px;border:1px solid var(--border);background:#111c2a;color:var(--text);cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
.station .name{font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.station .playlist{font-size:12px;color:var(--muted);font-style:italic;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
/* Ensure playlist line is always positioned under name with better spacing */
.station .name + .playlist { margin-top: 2px; }
/* New: Wrapper for name + playlist in favorites to keep grid intact */
.station-info { display: flex; flex-direction: column; gap: 1px; min-height: 0; overflow: hidden; } /* min-height:0 prevents flex growth issues; added overflow: hidden */
.station .actions{display:flex;gap:6px}
.station .open{border:1px solid var(--border);background:0 0;color:var(--muted);padding:6px 10px;border-radius:8px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
.station.active{outline:2px solid var(--brand)}

/* Favorites-specific styles */
.fav-btn { background: var(--success); color: white; border-color: var(--success); }
.fav-btn.active { background: var(--accent); border-color: var(--accent); }

/* Buffering spinner */
.spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid var(--spinner); border-radius: 50%; border-top-color: transparent; animation: spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.buffering .play { opacity: 0.5; }

/* Equalizer modal */
#eqModal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 100; align-items: center; justify-content: center; }
#eqModal.show { display: flex; }
.eq-content { background: var(--card); padding: 24px; border-radius: 12px; max-width: 300px; width: 90%; color: var(--text); position: relative; } /* Added position relative */
.eq-content h3 { color: var(--text); margin-top: 0; }
.eq-content label { display: block; color: var(--text); margin: 8px 0 0 0; }
.eq-slider { width: 100%; margin: 8px 0; }
.eq-preset { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; } /* Added flex-wrap for more presets */
.eq-preset button { flex: 1; padding: 8px; border: 1px solid var(--border); background: var(--bg-soft); color: var(--text); cursor: pointer; border-radius: 6px; min-width: 60px; } /* Added min-width for better wrapping */
.eq-content button { color: var(--text); }
/* Close button as small icon in top-right */
#eqClose { position: absolute; top: 12px; right: 12px; background: none; border: none; color: var(--muted); cursor: pointer; padding: 4px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background 0.2s; }
#eqClose:hover { background: var(--bg-soft); }

/* Favorites empty state */
.favorites-empty { text-align: center; padding: 40px; color: var(--muted); }

/* Player base styles */
.player{position:fixed;left:0;right:0;bottom:0;display:grid;grid-template-columns:repeat(6, auto) 1fr auto;align-items:center;gap:10px;padding:10px 12px;border-top:1px solid var(--border);background:linear-gradient(180deg,transparent,rgba(0,0,0,6%)),var(--bg-soft);backdrop-filter:saturate(1.2) blur(6px)}
.transport { display: contents; }
.player button{height:40px;width:40px;border-radius:10px;border:1px solid var(--border);background:#111c2a;color:var(--text);cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
.player .now{min-width:0; text-align: left;}
.now-station{font-weight:700;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.now-song{color:var(--muted);font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.now-meta{color:var(--muted);font-size:12px;opacity:.9;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
/* Use only one compact metadata line under the station title */
.now-meta{display:none}

.volume{display:flex;align-items:center;gap:8px;min-width:140px;justify-content:flex-end}
.volume-percentage{font-size:13px;color:var(--muted);width:4ch;text-align:right;flex-shrink:0}
#volumeRange{width:100px;flex:1}
.row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.small{color:var(--muted);font-size:13px}
a.link{color:var(--brand);text-decoration:none}
a.link:hover{text-decoration:underline}

/* Improved mobile: Stack now on top, then transport bar (left-aligned media keys), then volume bar (right-aligned) */
@media (max-width: 680px) {
  .player {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 8px 12px;
  }

  .player .now {
    order: 1;
    width: 100%;
    text-align: center;
    margin-bottom: 4px;
  }

  .transport {
    order: 2;
    display: flex;
    justify-content: flex-start;
    gap: 4px;
    flex-wrap: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    padding-bottom: 4px;
  }

  .player .volume {
    order: 3;
    justify-content: flex-end;
    gap: 4px;
    flex-shrink: 0;
  }

  /* Slightly tighter UI for small screens */
  .now-station { font-size: 14px; }
  .now-song    { font-size: 12px; }
  #volumeRange { width: 80px; flex: 1; max-width: 60px; }

  /* Ensure buttons are visible and not hidden */
  .player button {
    flex-shrink: 0;
    min-width: 36px;
    min-height: 36px;
  }

  #playPauseBtn {
    width: 42px;
    height: 42px;
    font-size: 18px;
  }
}

/* The hidden audio element shouldn't affect layout */
.player audio { display: none; }

/* Optional: give content a bit more bottom padding when the player becomes two rows */
@media (max-width: 680px) {
  .grid, .stations { padding-bottom: 140px; }
}

/* Extra-small phones: Further optimizations, but keep all buttons visible */
@media (max-width: 420px) {
  .player {
    gap: 6px;
    padding: 6px 8px;
  }

  .transport {
    gap: 2px;
  }

  .player button {
    width: 32px;
    height: 32px;
    border-radius: 6px;
    font-size: 14px;
  }

  #playPauseBtn {
    width: 36px;
    height: 36px;
    font-size: 16px;
  }

  .volume {
    gap: 2px;
    min-width: auto;
  }

  #volumeRange { 
    width: 50px; 
    flex: 1; 
    max-width: 50px;
  }

  .volume-percentage { 
    font-size: 11px; 
    width: auto; 
    min-width: 3ch; 
  }

  /* Slightly reduce bottom padding since the bar is shorter but ensure space */
  .grid, .stations { padding-bottom: 130px; }
}

/* The audio element stays hidden */
.player audio { display: none; }

/* SVG icons */
.icon { width: 20px; height: 20px; display: inline-block; vertical-align: middle; color: inherit; }
.brand .icon { width: 18px; height: 18px; }
.player button .icon { width: 18px; height: 18px; }
.station .play .icon { width: 18px; height: 18px; }
.station .open .icon { width: 16px; height: 16px; }
.player button svg, .station .open svg { pointer-events: none; } /* avoid eating button clicks */

/* New icons for quick wins */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.fav-icon { transition: color 0.2s; }
</style>
<noscript>This site needs JavaScript to load your playlists.</noscript>

<!-- SVG sprite: place once -->
<svg xmlns="http://www.w3.org/2000/svg" style="position:absolute;width:0;height:0;overflow:hidden" aria-hidden="true" focusable="false">
  <symbol id="i-play" viewBox="0 0 24 24">
    <path d="M8 5v14l11-7-11-7z" fill="currentColor"/>
  </symbol>

  <symbol id="i-pause" viewBox="0 0 24 24">
    <rect x="6" y="5" width="4" height="14" rx="1" fill="currentColor"/>
    <rect x="14" y="5" width="4" height="14" rx="1" fill="currentColor"/>
  </symbol>

  <symbol id="i-prev" viewBox="0 0 24 24">
    <rect x="5" y="5" width="2" height="14" rx="1" fill="currentColor"/>
    <path d="M20 19L10 12l10-7v14z" fill="currentColor"/>
  </symbol>

  <symbol id="i-next" viewBox="0 0 24 24">
    <rect x="17" y="5" width="2" height="14" rx="1" fill="currentColor"/>
    <path d="M4 19l10-7L4 5v14z" fill="currentColor"/>
  </symbol>

  <symbol id="i-shuffle" viewBox="0 0 24 24">
    <path d="M4 6h3c3 0 5 4 9 4h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M16 4l4 4-4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M4 18h3c3 0 5-4 9-4h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M16 14l4 4-4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </symbol>

  <symbol id="i-volume-high" viewBox="0 0 24 24">
    <path d="M5 9h4l5-4v14l-5-4H5z" fill="currentColor"/>
    <path d="M17 8c1.8 1.2 3 3 3 5s-1.2 3.8-3 5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    <path d="M17 5c2.9 1.8 5 4.9 5 8s-2.1 6.2-5 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity=".6"/>
  </symbol>

  <symbol id="i-volume-off" viewBox="0 0 24 24">
    <path d="M5 9h4l5-4v14l-5-4H5z" fill="currentColor"/>
    <path d="M18 9l4 4m0-4l-4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </symbol>

  <symbol id="i-plus" viewBox="0 0 24 24">
    <path d="M12 5v14M5 12h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </symbol>

  <symbol id="i-minus" viewBox="0 0 24 24">
    <path d="M5 12h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </symbol>

  <symbol id="i-external" viewBox="0 0 24 24">
    <path d="M14 3h7v7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M21 3L11 13" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    <path d="M5 7a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </symbol>

  <symbol id="i-headphones" viewBox="0 0 24 24">
    <path d="M4 13a8 8 0 0 1 16 0" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    <rect x="3" y="13" width="4" height="7" rx="1" fill="currentColor"/>
    <rect x="17" y="13" width="4" height="7" rx="1" fill="currentColor"/>
  </symbol>

  <symbol id="i-chevron-left" viewBox="0 0 24 24">
    <path d="M14 18L8 12l6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </symbol>

  <!-- New icons -->
  <symbol id="i-star" viewBox="0 0 24 24">
    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="currentColor"/>
  </symbol>

  <symbol id="i-eq" viewBox="0 0 24 24">
    <rect x="3" y="3" width="3" height="18" rx="1.5" fill="currentColor"/>
    <rect x="9" y="6" width="3" height="12" rx="1.5" fill="currentColor"/>
    <rect x="15" y="3" width="3" height="18" rx="1.5" fill="currentColor"/>
    <rect x="21" y="9" width="3" height="6" rx="1.5" fill="currentColor"/>
  </symbol>

  <symbol id="i-close" viewBox="0 0 24 24">
    <line x1="18" y1="6" x2="6" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    <line x1="6" y1="6" x2="18" y2="18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </symbol>

  <symbol id="i-home" viewBox="0 0 24 24">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" fill="currentColor"/>
  </symbol>
</svg>

<header class="topbar">
  <a class="brand" id="brand" href="#">
    <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-headphones" xlink:href="#i-headphones"></use></svg>
    <span>My Radio</span>
  </a>
  <input type="search" id="searchInput" placeholder="Search…" autocomplete="off">
</header>

<main id="app">
  <div class="loading" id="appLoading">Loading…</div>
</main>

<!-- Equalizer Modal -->
<div id="eqModal">
  <div class="eq-content">
    <h3>Equalizer</h3>
    <label>Bass: <input class="eq-slider" type="range" id="eqBass" min="-12" max="12" value="0" step="1"></label>
    <label>Mid: <input class="eq-slider" type="range" id="eqMid" min="-12" max="12" value="0" step="1"></label>
    <label>Treble: <input class="eq-slider" type="range" id="eqTreble" min="-12" max="12" value="0" step="1"></label>
    <div class="eq-preset">
      <button id="eqPresetFlat">Flat</button>
      <button id="eqPresetRock">Rock</button>
      <button id="eqPresetPop">Pop</button>
      <button id="eqPresetJazz">Jazz</button>
      <button id="eqPresetClassical">Classical</button>
      <button id="eqPresetBassBoost">Bass Boost</button>
    </div>
    <button id="eqClose" aria-label="Close Equalizer"></button>
  </div>
</div>

<footer class="player" id="playerBar" aria-label="Audio player" hidden>
  <div class="transport">
    <button id="prevBtn" title="Previous" aria-label="Previous">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-prev" xlink:href="#i-prev"></use></svg>
    </button>
    <button id="playPauseBtn" title="Play/Pause" aria-label="Play">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-play" xlink:href="#i-play"></use></svg>
    </button>
    <button id="nextBtn" title="Next" aria-label="Next">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-next" xlink:href="#i-next"></use></svg>
    </button>
    <button id="shuffleBtn" title="Shuffle" aria-label="Shuffle">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-shuffle" xlink:href="#i-shuffle"></use></svg>
    </button>
    <button id="homeBtn" title="Home" aria-label="Go to home">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-home" xlink:href="#i-home"></use></svg>
    </button>
    <button id="eqBtn" title="Equalizer" aria-label="Equalizer">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-eq" xlink:href="#i-eq"></use></svg>
    </button>
  </div>
  <div class="now">
    <div id="nowStation" class="now-station">No station selected</div>
    <div id="nowSong" class="now-song">Fetching...</div>
    <div id="nowMeta" class="now-meta"></div>
  </div>
  <div class="volume">
    <button id="muteBtn" title="Mute/Unmute" aria-label="Mute">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-volume-high" xlink:href="#i-volume-high"></use></svg>
    </button>
    <button id="volDownBtn" title="Volume Down" aria-label="Volume Down">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-minus" xlink:href="#i-minus"></use></svg>
    </button>
    <input id="volumeRange" type="range" min="0" max="1" step="0.01" value="1">
    <button id="volUpBtn" title="Volume Up" aria-label="Volume Up">
      <svg class="icon" aria-hidden="true" focusable="false"><use href="#i-plus" xlink:href="#i-plus"></use></svg>
    </button>
    <span id="volumePercentage" class="volume-percentage">100%</span>
  </div>
  <audio id="audio" preload="none" crossorigin="anonymous"></audio>
</footer>

<script>
"use strict";

/* Config
   If your streams block cross-origin metadata (most do), deploy a tiny CORS proxy
   (e.g., a Cloudflare Worker) and set METADATA_PROXY to its URL. Only metadata
   fetches go through the proxy; audio playback stays direct.

   Example Worker (deploy this separately and set METADATA_PROXY to its URL):
   -------------------------------------------------------------------------
   export default {
     async fetch(request) {
       const url = new URL(request.url);
       const target = url.searchParams.get("u");
       if (!target) return new Response("Missing ?u=", { status: 400 });

       const upstream = await fetch(target, {
         method: request.method,
         headers: {
           "Icy-MetaData": "1",
           ...(request.headers.get("Range") ? { Range: request.headers.get("Range") } : {}),
         },
         redirect: "follow",
       });

       const hdr = new Headers(upstream.headers);
       hdr.set("access-control-allow-origin", "*");
       hdr.set("access-control-expose-headers", "*");
       hdr.set("cache-control", "no-store");

       return new Response(upstream.body, {
         status: upstream.status,
         statusText: upstream.statusText,
         headers: hdr,
       });
     }
   };
*/
const CONFIG = {
  API_INDEX_URL: "https://tvbd.github.io/radio/bd.json",
  SITE_TITLE: "My Radio",
  METADATA_PROXY: "" // e.g. "https://your-worker.example.workers.dev/"
};

/* DOM and State */
const els = {};
const state = {
  index: null,
  indexBase: null,
  indexDir: null,
  repoRoot: null,
  playlistMap: new Map(),
  currentRoute: null,
  currentSlug: null,
  currentPlaylist: null,
  currentPlaylistUrl: null,
  currentItems: [],
  currentIndex: -1,
  audio: null,
  audioContext: null,
  audioSource: null,
  gainNode: null,
  compressor: null,
  bassFilter: null,
  midFilter: null,
  trebleFilter: null,
  filter: "",
  linearVolume: 1, // Track linear volume separately for UI
  // Robust "now playing" state
  currentSong: "",
  songPriority: 0, // higher wins
  streamMeta: {},
  metaSeq: 0,       // session guard for async watchers
  npAbort: null,    // AbortController for ICY loop
  npStatusTimer: null,
  npMSessionTimer: null,
  // Playback watchdog to skip stalled streams
  playSeq: 0,
  playWatchdog: null,
  // New states
  favorites: [],
  buffering: false,
  shuffleTargetSlug: null,
  eqPresets: { 
    flat: {bass:0,mid:0,treble:0}, 
    rock: {bass:6,mid:0,treble:4}, 
    pop: {bass:2,mid:-2,treble:6},
    jazz: {bass:2,mid:4,treble:2},
    classical: {bass:0,mid:2,treble:4},
    bassboost: {bass:8,mid:0,treble:-2}
  },
  eqSettings: {bass:0,mid:0,treble:0}
};

/* Boot */
document.addEventListener("DOMContentLoaded", init);
function init() {
  cacheDom();
  wireUI();
  registerServiceWorker();
  boot();
  loadFavorites();
  loadEQ();
}

function cacheDom() {
  els.app = document.getElementById("app");
  els.appLoading = document.getElementById("appLoading");
  els.searchInput = document.getElementById("searchInput");
  els.playerBar = document.getElementById("playerBar");
  els.audio = document.getElementById("audio");
  els.playPauseBtn = document.getElementById("playPauseBtn");
  els.prevBtn = document.getElementById("prevBtn");
  els.nextBtn = document.getElementById("nextBtn");
  els.shuffleBtn = document.getElementById("shuffleBtn");
  els.homeBtn = document.getElementById("homeBtn");
  els.muteBtn = document.getElementById("muteBtn");
  els.volumeRange = document.getElementById("volumeRange");
  els.volumePercentage = document.getElementById("volumePercentage");
  els.volUpBtn = document.getElementById("volUpBtn");
  els.volDownBtn = document.getElementById("volDownBtn");
  els.nowStation = document.getElementById("nowStation");
  els.nowSong = document.getElementById("nowSong");
  els.nowMeta = document.getElementById("nowMeta");
  els.brand = document.getElementById("brand");
  // New elements
  els.eqModal = document.getElementById("eqModal");
  els.eqBass = document.getElementById("eqBass");
  els.eqMid = document.getElementById("eqMid");
  els.eqTreble = document.getElementById("eqTreble");
  els.eqPresetFlat = document.getElementById("eqPresetFlat");
  els.eqPresetRock = document.getElementById("eqPresetRock");
  els.eqPresetPop = document.getElementById("eqPresetPop");
  els.eqPresetJazz = document.getElementById("eqPresetJazz");
  els.eqPresetClassical = document.getElementById("eqPresetClassical");
  els.eqPresetBassBoost = document.getElementById("eqPresetBassBoost");
  els.eqClose = document.getElementById("eqClose");
  els.eqBtn = document.getElementById("eqBtn");
  state.audio = els.audio;
  updateBrandText();
  updateTitle();
  // Set close icon
  els.eqClose.innerHTML = icon("close", 16);
}

function wireUI() {
  window.addEventListener("hashchange", onRouteChange);
  els.searchInput.addEventListener("input", debounce(onSearch, 120));

  els.playPauseBtn.addEventListener("click", togglePlayPause);
  els.prevBtn.addEventListener("click", playPrev);
  els.nextBtn.addEventListener("click", playNext);
  els.shuffleBtn.addEventListener("click", shuffle);
  els.homeBtn.addEventListener("click", () => { location.hash = ""; onRouteChange(); });

  els.muteBtn.addEventListener("click", toggleMute);
  els.volumeRange.addEventListener("input", (e) => setVolume(parseFloat(e.target.value)));
  els.volUpBtn.addEventListener("click", volumeUp);
  els.volDownBtn.addEventListener("click", volumeDown);

  // New UI
  els.eqBtn.addEventListener("click", () => els.eqModal.classList.add("show"));
  els.eqClose.addEventListener("click", () => els.eqModal.classList.remove("show"));
  els.eqBass.addEventListener("input", updateEQ);
  els.eqMid.addEventListener("input", updateEQ);
  els.eqTreble.addEventListener("input", updateEQ);
  els.eqPresetFlat.addEventListener("click", () => loadEQPreset("flat"));
  els.eqPresetRock.addEventListener("click", () => loadEQPreset("rock"));
  els.eqPresetPop.addEventListener("click", () => loadEQPreset("pop"));
  els.eqPresetJazz.addEventListener("click", () => loadEQPreset("jazz"));
  els.eqPresetClassical.addEventListener("click", () => loadEQPreset("classical"));
  els.eqPresetBassBoost.addEventListener("click", () => loadEQPreset("bassboost"));

  els.audio.addEventListener("playing", () => { updatePlayIcon(true); clearPlayWatchdog(); setBuffering(false); });
  els.audio.addEventListener("canplay", () => { clearPlayWatchdog(); setBuffering(false); });
  els.audio.addEventListener("canplaythrough", () => { clearPlayWatchdog(); setBuffering(false); });
  els.audio.addEventListener("pause", () => updatePlayIcon(false));
  els.audio.addEventListener("volumechange", updateVolumeDisplay);
  els.audio.addEventListener("error", onAudioError);

  // Keyboard nav
  document.addEventListener("keydown", onKeydown);

  // Android/mobile fix: Resume audio/context on visibility/focus changes to prevent stopping in background
  document.addEventListener("visibilitychange", handleVisibilityChange);
  window.addEventListener("focus", handleVisibilityChange);
  window.addEventListener("blur", () => {
    if ("mediaSession" in navigator) {
      navigator.mediaSession.playbackState = "paused";
    }
  });

  restoreVolume();
}

function handleVisibilityChange() {
  if (document.hidden) return;
  // Resume AudioContext if suspended (common on Android when tab/app backgrounds)
  if (state.audioContext && state.audioContext.state === "suspended") {
    state.audioContext.resume().then(() => {
      console.debug("AudioContext resumed on visibility change");
    }).catch(e => console.warn("Failed to resume AudioContext:", e));
  }
  // Resume audio playback if it was paused unexpectedly but stream is loaded
  if (els.audio.src && els.audio.paused && !state.buffering) {
    playAudio();
  }
  // Update MediaSession state
  if ("mediaSession" in navigator && !els.audio.paused) {
    navigator.mediaSession.playbackState = "playing";
  }
}

async function registerServiceWorker() {
  if ("serviceWorker" in navigator) {
    try {
      const swCode = `
        const CACHE_NAME = 'radio-v1';
        const urlsToCache = [
          '${CONFIG.API_INDEX_URL}',
          // Add more static assets if needed
        ];

        self.addEventListener('install', (event) => {
          event.waitUntil(
            caches.open(CACHE_NAME)
              .then((cache) => cache.addAll(urlsToCache))
          );
        });

        self.addEventListener('fetch', (event) => {
          event.respondWith(
            caches.match(event.request)
              .then((response) => {
                if (response) return response;
                return fetch(event.request).then((fetchResponse) => {
                  if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== 'basic') {
                    return fetchResponse;
                  }
                  return caches.open(CACHE_NAME).then((cache) => {
                    cache.put(event.request, fetchResponse.clone());
                    return fetchResponse;
                  });
                });
              })
          );
        });
      `;
      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);
      const registration = await navigator.serviceWorker.register(swUrl);
      console.log('SW registered:', registration);
    } catch (err) {
      console.warn('SW registration failed:', err);
    }
  }
}

async function boot() {
  try {
    showLoading(true);
    state.indexBase = new URL(CONFIG.API_INDEX_URL, location.href);
    state.indexDir = new URL(".", state.indexBase.href);
    state.repoRoot = new URL("..", state.indexBase.href);

    const index = await fetchJson(state.indexBase.href);
    state.index = index;
    buildPlaylistMap(index);
    onRouteChange(); // Always call onRouteChange to handle current hash (including empty)
  } catch (err) {
    showError(`Failed to load index: ${escapeHtml(err.message || err)}`);
  } finally {
    showLoading(false);
  }
}

/* UI helpers */
function showLoading(v) {
  els.appLoading && els.appLoading.classList.toggle("loading", !!v);
  if (v) els.app.innerHTML = `<div class="loading">Loading…</div>`;
}
function showError(msg) {
  els.app.innerHTML = `<div class="error">${escapeHtml(msg)}</div>`;
}
function buildPlaylistMap(index) {
  state.playlistMap.clear();
  const list = Array.isArray(index.playlists) ? index.playlists : [];
  for (const p of list) {
    const slug = slugFromPlaylist(p);
    const url = resolvePlaylistUrl(p.url);
    state.playlistMap.set(slug, { name: p.name || slug, url, count: p.count ?? null, raw: p });
  }
}
function slugFromPlaylist(p) {
  if (p && p.url) try {
    const file = p.url.split("/").pop() || "";
    if (file) return file.replace(/\.json(\?.*)?$/i, "").toLowerCase();
  } catch(e) { console.warn("Failed to parse slug from playlist URL:", e); }
  return slugify(p?.name || "");
}
function slugify(s) {
  return String(s).trim().toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");
}
function resolvePlaylistUrl(u) {
  if (!u) return "";
  return /^https?:\/\//i.test(u) ? dedupeApi(u)
       : /^\/\//.test(u) ? dedupeApi(location.protocol + u)
       : u.startsWith("/") ? dedupeApi(new URL(u.replace(/^\//,""), state.repoRoot).href)
       : dedupeApi(u.startsWith("api/") ? new URL(u, state.repoRoot).href : new URL(u, state.indexDir).href);
}
function dedupeApi(u) { return u.replace(/(?:\/api)+(\/)/g, "/api$1"); }

function onRouteChange() {
  const parts = getHashParts();
  window.scrollTo(0, 0);
  els.searchInput.value = "";
  state.filter = "";

  if (parts[0] === "favorites") {
    state.currentRoute = "favorites";
    state.currentSlug = null;
    renderFavorites();
    updateTitle("Favorites");
    setSearchPlaceholder("Search favorites…");
    updateBrandText("back");
    return;
  }

  if (parts.length === 0) {
    state.currentRoute = "";
    state.currentSlug = null;
    renderHome();
    updateTitle();
    setSearchPlaceholder("Search playlists…");
    updateBrandText("home");
    return;
  }

  if (parts[0] === "p" && parts[1]) {
    const slug = parts[1].toLowerCase();
    state.currentRoute = "p";
    state.currentSlug = slug;
    renderPlaylist(slug);
    setSearchPlaceholder("Search streams in this playlist…");
    updateBrandText("back");
    return;
  }

  state.currentRoute = "";
  state.currentSlug = null;
  renderHome();
  updateBrandText("home");
}

function getHashParts() {
  const h = (location.hash || "").replace(/^#/,"");
  return h.split("/").map(p => p.trim()).filter(Boolean);
}
function updateTitle(t) {
  document.title = t ? `${t} — ${CONFIG.SITE_TITLE}` : CONFIG.SITE_TITLE;
}
function updateBrandText(mode="home") {
  if (!els.brand) return;
  if (mode === "back") {
    els.brand.innerHTML = `${icon("chevron-left", 18)} <span>Go Back</span>`;
    els.brand.href = "#";
  } else {
    els.brand.innerHTML = `${icon("headphones", 18)} <span>${CONFIG.SITE_TITLE}</span>`;
    els.brand.href = "#";
  }
}
function setSearchPlaceholder(p) {
  els.searchInput.placeholder = p;
}
function onSearch(e) {
  state.filter = e.target.value.trim().toLowerCase();
  if (state.currentRoute === "favorites") renderFavorites(true);
  else if (state.currentRoute === "p" && state.currentPlaylist) renderPlaylistContent(state.currentPlaylist, true);
  else renderHome(true);
}

/* Renderers */
function renderHome(skipTitle=false) {
  if (!state.index) { els.app.innerHTML = `<div class="loading">Loading…</div>`; return; }

  const q = state.filter;
  const all = [...state.playlistMap.entries()].map(([slug, data]) => ({ slug, ...data }));
  const visible = q ? all.filter(p => p.name.toLowerCase().includes(q) || p.slug.includes(q)) : all;

  if (!skipTitle) updateTitle();

  if (!visible.length && state.favorites.length === 0) {
    els.app.innerHTML = `
      <div class="row">
        <div class="section-title">Playlists</div>
        <div class="small">0 of ${all.length} playlists (filtered)</div>
      </div>
      <div class="empty">No playlists match “${escapeHtml(q)}”.</div>
    `;
    return;
  }

  const frag = document.createDocumentFragment();

  const row = document.createElement("div");
  row.className = "row";
  const countText = q ? `${visible.length} of ${all.length} playlists (filtered)` : `${all.length} playlists`;
  row.innerHTML = `
    <div class="section-title">Playlists</div>
    <div class="small">${countText}</div>
  `;
  frag.appendChild(row);

  const grid = document.createElement("div");
  grid.className = "grid";

  // Add Favorites card first if there are any
  if (state.favorites.length > 0 && (!q || "favorites".includes(q.toLowerCase()))) {
    const a = document.createElement("a");
    a.className = "card";
    a.href = "#/favorites";
    a.innerHTML = `
      <span class="title">⭐ Favorites</span>
      <span class="meta">${state.favorites.length} streams</span>
    `;
    grid.appendChild(a);
  }

  for (const p of visible) {
    const a = document.createElement("a");
    a.className = "card";
    a.href = `#/p/${p.slug}`;
    a.innerHTML = `
      <span class="title">${escapeHtml(p.name)}</span>
      <span class="meta">${p.count ?? "—"} streams</span>
    `;
    grid.appendChild(a);
  }
  frag.appendChild(grid);
  els.app.replaceChildren(frag);
}

function renderFavorites(skipTitle = false) {
  if (!skipTitle) updateTitle("Favorites");

  const q = state.filter;
  const items = state.favorites;
  const visible = q ? items.filter(f => f.name.toLowerCase().includes(q) || (f.playlistName && f.playlistName.toLowerCase().includes(q))) : items;

  const frag = document.createDocumentFragment();

  const row = document.createElement("div");
  row.className = "row";
  row.innerHTML = `
    <div class="section-title">Favorites</div>
    <div class="small">Streams: ${visible.length} ${q ? `(filtered)` : ""}</div>
  `;
  frag.appendChild(row);

  if (!visible.length) {
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = `<p>No favorites match “${escapeHtml(q)}”. <a href="#" class="link" onclick="location.hash=''">Browse playlists</a> and star some stations!</p>`;
    frag.appendChild(empty);
    els.app.replaceChildren(frag);
    return;
  }

  const ul = document.createElement("ul");
  ul.className = "stations";
  state.currentItems = items; // Set for navigation
  visible.forEach((item, localIdx) => {
    const globalIdx = items.findIndex(x => x.url === item.url);
    const li = document.createElement("li");
    li.className = "station";
    const isActive = state.currentIndex >= 0 && state.currentItems[state.currentIndex]?.url === item.url;
    if (isActive) li.classList.add("active");
    li.tabIndex = 0; // For keyboard nav

    const btn = document.createElement("button");
    btn.className = "play";
    btn.title = "Play";
    btn.innerHTML = icon("play", 18);
    btn.addEventListener("click", ev => {
      ev.stopPropagation();
      playFromList(state.currentItems, globalIdx);
    });

    // Wrap name and playlist in a single div for the middle grid column
    const stationInfo = document.createElement("div");
    stationInfo.className = "station-info";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = item.name || "(Unnamed)";

    const playlist = document.createElement("div");
    playlist.className = "playlist";
    playlist.textContent = item.playlistName ? `from "${item.playlistName}"` : "";

    stationInfo.appendChild(name);
    stationInfo.appendChild(playlist);

    const actions = document.createElement("div");
    actions.className = "actions";
    const open = document.createElement("button");
    open.className = "open";
    open.title = "Open stream URL in new tab";
    open.innerHTML = icon("external", 16);
    open.addEventListener("click", ev => {
      ev.stopPropagation();
      item.url && window.open(item.url, "_blank", "noopener");
    });

    const favBtn = document.createElement("button");
    favBtn.className = "fav-btn open";
    favBtn.title = "Remove from favorites";
    favBtn.innerHTML = icon("star", 16);
    favBtn.addEventListener("click", ev => {
      ev.stopPropagation();
      removeFavorite(item.url);
    });

    actions.appendChild(open);
    actions.appendChild(favBtn);

    li.appendChild(btn);
    li.appendChild(stationInfo);
    li.appendChild(actions);

    li.addEventListener("click", () => playFromList(state.currentItems, globalIdx));
    li.addEventListener("keydown", (e) => {
      if (e.key === "Enter") playFromList(state.currentItems, globalIdx);
      else if (e.key === "ArrowDown") {
        e.preventDefault();
        const next = ul.querySelectorAll('.station')[Array.from(ul.querySelectorAll('.station')).indexOf(li) + 1];
        next?.focus();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prev = ul.querySelectorAll('.station')[Array.from(ul.querySelectorAll('.station')).indexOf(li) - 1];
        prev?.focus();
      }
    });

    ul.appendChild(li);
  });

  frag.appendChild(ul);
  els.app.replaceChildren(frag);
  refreshActiveStationHighlight();
}

async function renderPlaylist(slug) {
  const known = state.playlistMap.get(slug);
  const fallback = known?.url || resolvePlaylistUrl(`playlists/${slug}.json`);
  const candidates = unique([
    fallback,
    resolvePlaylistUrl(`playlists/${slug}.json`),
    resolvePlaylistUrl(`api/playlists/${slug}.json`)
  ]);
  const name = known?.name || slug;

  updateTitle(name);
  els.app.innerHTML = `<div class="loading">Loading “${escapeHtml(name)}”…</div>`;

  try {
    const { url, data } = await fetchFirstOkJson(candidates);
    state.currentPlaylist = data;
    state.currentPlaylistUrl = url;
    state.currentItems = Array.isArray(data.items) ? data.items : [];
    renderPlaylistContent(data);

    // Auto-play random stream if this was a shuffle target
    if (state.shuffleTargetSlug === slug) {
      if (state.currentItems.length > 0) {
        const i = Math.floor(Math.random() * state.currentItems.length);
        playFromList(state.currentItems, i);
      }
      state.shuffleTargetSlug = null;
    }
  } catch (err) {
    const last = err?.__lastTried || candidates[candidates.length - 1] || fallback;
    // Clear shuffle flag on error to avoid stale state
    if (state.shuffleTargetSlug === slug) {
      state.shuffleTargetSlug = null;
    }
    console.error("Playlist fetch failed:", last, err);
    els.app.innerHTML = `
      <div class="error">
        Failed to load playlist: ${escapeHtml(err.message || err)}<br/>
        Tried URL: <a class="link" href="${escapeHtml(last)}" target="_blank" rel="noopener">${escapeHtml(last)}</a>
      </div>
    `;
  }
}

function renderPlaylistContent(pl, skipTitle=false) {
  const title = pl.name || state.currentSlug || "Playlist";
  const total = pl.count ?? (pl.items?.length || 0);
  if (!skipTitle) updateTitle(title);

  const q = state.filter;
  const items = state.currentItems || [];
  const visible = q ? items.filter(it => (it.name || "").toLowerCase().includes(q)) : items;

  const frag = document.createDocumentFragment();

  const row = document.createElement("div");
  row.className = "row";
  row.innerHTML = `
    <div class="section-title">${escapeHtml(title)}</div>
    <div class="small">Streams: ${visible.length} ${q ? `(filtered)` : `of ${total}`}</div>
  `;
  frag.appendChild(row);

  if (state.currentPlaylistUrl || pl.sourceFile || pl.generatedAt) {
    const meta = document.createElement("div");
    meta.className = "playlist-meta";
    const parts = [];
    if (state.currentPlaylistUrl) {
      const url = escapeHtml(state.currentPlaylistUrl);
      parts.push(`Source: <a class="link" href="${url}" target="_blank" rel="noopener">${url}</a>`);
    } else if (pl.sourceFile) {
      parts.push(`Source: ${escapeHtml(pl.sourceFile)}`);
    }
    if (pl.generatedAt) parts.push(`Updated: ${escapeHtml(toLocalTime(pl.generatedAt))}`);
    meta.innerHTML = parts.join(" • ");
    frag.appendChild(meta);
  }

  if (!visible.length) {
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.textContent = `No streams match “${state.filter}”.`;
    frag.appendChild(empty);
    els.app.replaceChildren(frag);
    return;
  }

  const ul = document.createElement("ul");
  ul.className = "stations";
  visible.forEach((item, localIdx) => {
    const globalIdx = state.currentItems.findIndex(x => x.url === item.url);
    const li = document.createElement("li");
    li.className = "station";
    const isActive = state.currentIndex >= 0 && state.currentItems[state.currentIndex] === item;
    if (isActive) li.classList.add("active");
    li.tabIndex = 0; // Keyboard nav

    const btn = document.createElement("button");
    btn.className = "play";
    btn.title = "Play";
    btn.innerHTML = icon("play", 18);
    btn.addEventListener("click", ev => {
      ev.stopPropagation();
      playFromList(state.currentItems, globalIdx);
    });

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = item.name || "(Unnamed)";

    const actions = document.createElement("div");
    actions.className = "actions";
    const open = document.createElement("button");
    open.className = "open";
    open.title = "Open stream URL in new tab";
    open.innerHTML = icon("external", 16);
    open.addEventListener("click", ev => {
      ev.stopPropagation();
      item.url && window.open(item.url, "_blank", "noopener");
    });

    const isFav = state.favorites.some(f => f.url === item.url);
    const favBtn = document.createElement("button");
    favBtn.className = `open ${isFav ? 'fav-btn active' : ''}`;
    favBtn.title = isFav ? "Remove from favorites" : "Add to favorites";
    favBtn.innerHTML = icon("star", 16);
    favBtn.addEventListener("click", ev => {
      ev.stopPropagation();
      if (isFav) removeFavorite(item.url);
      else addFavorite(item, pl.name); // Pass playlist name
    });

    actions.appendChild(open);
    actions.appendChild(favBtn);

    li.appendChild(btn);
    li.appendChild(name);
    li.appendChild(actions);

    li.addEventListener("click", () => playFromList(state.currentItems, globalIdx));
    li.addEventListener("keydown", (e) => {
      if (e.key === "Enter") playFromList(state.currentItems, globalIdx);
      else if (e.key === "ArrowDown") {
        e.preventDefault();
        const next = ul.querySelectorAll('.station')[Array.from(ul.querySelectorAll('.station')).indexOf(li) + 1];
        next?.focus();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prev = ul.querySelectorAll('.station')[Array.from(ul.querySelectorAll('.station')).indexOf(li) - 1];
        prev?.focus();
      }
    });

    ul.appendChild(li);
  });

  frag.appendChild(ul);
  els.app.replaceChildren(frag);
  refreshActiveStationHighlight();
}

function addFavorite(item, playlistName) {
  if (!state.favorites.some(f => f.url === item.url)) {
    state.favorites.push({ ...item, playlistName });
    saveFavorites();
    if (state.currentRoute === "p") renderPlaylistContent(state.currentPlaylist, true);
    else if (state.currentRoute === "") renderHome(true); // Refresh home to update favorites card
  }
}

function removeFavorite(url) {
  state.favorites = state.favorites.filter(f => f.url !== url);
  saveFavorites();
  if (state.currentRoute === "p") renderPlaylistContent(state.currentPlaylist, true);
  else if (state.currentRoute === "favorites") renderFavorites(true);
  else if (state.currentRoute === "") renderHome(true); // Refresh home to update favorites card
}

function playFromList(list, idx) {
  const item = list[idx];
  if (!item) return;
  state.currentIndex = idx;
  setNowPlaying(item);
  loadAndPlay(item.url, item);
  refreshActiveStationHighlight();
}

function setNowPlaying(item) {
  els.nowStation.textContent = item?.name || "Unknown Station";
  els.nowSong.textContent = "";
  if (els.nowMeta) els.nowMeta.textContent = "";

  state.currentSong = "";
  state.songPriority = 0;
  state.streamMeta = {};
  els.playerBar.hidden = false;

  persistSession();

  // Set MediaSession for better mobile handling (prevents pausing on Android)
  if ("mediaSession" in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: item?.name || "Radio Stream",
      artist: "",
      album: ""
    });
    navigator.mediaSession.playbackState = "playing";
    navigator.mediaSession.setActionHandler("play", () => playAudio());
    navigator.mediaSession.setActionHandler("pause", () => pauseAudio());
    navigator.mediaSession.setActionHandler("previoustrack", playPrev);
    navigator.mediaSession.setActionHandler("nexttrack", playNext);
  }
}

function setupAudioNormalization() {
  if (state.audioContext) return;
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    state.audioContext = new Ctx();
    state.audioSource = state.audioContext.createMediaElementSource(els.audio);

    // Volume gain node for overall level control (YouTube-like normalization boost)
    state.gainNode = state.audioContext.createGain();
    state.gainNode.gain.value = 1.0; // Neutral base; normalization handled by analyzer below

    // Enhanced Compressor for consistent loudness (more aggressive normalization)
    state.compressor = state.audioContext.createDynamicsCompressor();
    state.compressor.threshold.setValueAtTime(-24, state.audioContext.currentTime); // Standard broadcast threshold
    state.compressor.knee.setValueAtTime(30, state.audioContext.currentTime);
    state.compressor.ratio.setValueAtTime(4, state.audioContext.currentTime); // 4:1 ratio for gentle compression
    state.compressor.attack.setValueAtTime(0.003, state.audioContext.currentTime); // Fast attack
    state.compressor.release.setValueAtTime(0.25, state.audioContext.currentTime);

    // Add a limiter after compressor for peak control
    const limiter = state.audioContext.createDynamicsCompressor();
    limiter.threshold.setValueAtTime(-6, state.audioContext.currentTime);
    limiter.knee.setValueAtTime(0, state.audioContext.currentTime);
    limiter.ratio.setValueAtTime(20, state.audioContext.currentTime);
    limiter.attack.setValueAtTime(0.001, state.audioContext.currentTime);
    limiter.release.setValueAtTime(0.05, state.audioContext.currentTime);

    // Simple RMS analyzer for dynamic normalization (samples audio and adjusts gain to target -14 LUFS equivalent)
    const analyser = state.audioContext.createAnalyser();
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    let rms = 0;
    let targetRms = 0.2; // Target RMS for ~ -14 LUFS (empirical for radio streams)
    let normalizationGain = 1.0;

    const updateNormalization = () => {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i] * dataArray[i];
      }
      rms = Math.sqrt(sum / bufferLength) / 255;
      if (rms > 0.01) { // Avoid division by near-zero
        normalizationGain = Math.min(3.0, targetRms / rms); // Cap at +10dB boost
        state.gainNode.gain.setValueAtTime(normalizationGain, state.audioContext.currentTime);
      }
      requestAnimationFrame(updateNormalization);
    };
    updateNormalization();

    // EQ Filters
    state.bassFilter = state.audioContext.createBiquadFilter();
    state.bassFilter.type = 'lowshelf';
    state.bassFilter.frequency.setValueAtTime(320, state.audioContext.currentTime);
    state.midFilter = state.audioContext.createBiquadFilter();
    state.midFilter.type = 'peaking';
    state.midFilter.frequency.setValueAtTime(1000, state.audioContext.currentTime);
    state.midFilter.Q.setValueAtTime(1, state.audioContext.currentTime);
    state.trebleFilter = state.audioContext.createBiquadFilter();
    state.trebleFilter.type = 'highshelf';
    state.trebleFilter.frequency.setValueAtTime(3200, state.audioContext.currentTime);

    // Chain: source -> analyser -> gain (dynamic norm) -> bass -> mid -> treble -> compressor -> limiter -> destination
    state.audioSource.connect(analyser);
    analyser.connect(state.gainNode);
    state.gainNode.connect(state.bassFilter);
    state.bassFilter.connect(state.midFilter);
    state.midFilter.connect(state.trebleFilter);
    state.trebleFilter.connect(state.compressor);
    state.compressor.connect(limiter);
    limiter.connect(state.audioContext.destination);

    updateEQ(); // Apply saved settings
    applyVolumeCurve(); // Apply current volume
  } catch (e) {
    console.error("Failed to initialize Web Audio API for normalization:", e);
  }
}

function updateEQ() {
  state.eqSettings.bass = parseFloat(els.eqBass.value);
  state.eqSettings.mid = parseFloat(els.eqMid.value);
  state.eqSettings.treble = parseFloat(els.eqTreble.value);

  if (state.bassFilter) state.bassFilter.gain.setValueAtTime(state.eqSettings.bass, state.audioContext.currentTime);
  if (state.midFilter) state.midFilter.gain.setValueAtTime(state.eqSettings.mid, state.audioContext.currentTime);
  if (state.trebleFilter) state.trebleFilter.gain.setValueAtTime(state.eqSettings.treble, state.audioContext.currentTime);

  saveEQ();
}

function loadEQPreset(name) {
  const preset = state.eqPresets[name];
  if (preset) {
    els.eqBass.value = preset.bass;
    els.eqMid.value = preset.mid;
    els.eqTreble.value = preset.treble;
    updateEQ();
  }
}

function saveEQ() {
  localStorage.setItem("radio:eq", JSON.stringify(state.eqSettings));
}

function loadEQ() {
  try {
    const raw = localStorage.getItem("radio:eq");
    const saved = raw ? JSON.parse(raw) : {};
    state.eqSettings = { ...state.eqSettings, ...saved };
    if (els.eqBass) els.eqBass.value = state.eqSettings.bass;
    if (els.eqMid) els.eqMid.value = state.eqSettings.mid;
    if (els.eqTreble) els.eqTreble.value = state.eqSettings.treble;
  } catch(e) {
    console.error("Failed to load EQ:", e);
  }
}

function playAudio() {
  if (!els.audio.src) return;
  state.audioContext || setupAudioNormalization();
  if (state.audioContext && state.audioContext.state === "suspended") {
    state.audioContext.resume().catch(e => console.error("Audio context resume failed:", e));
  }
  els.audio.play().catch(e => {
    if (e.name !== "AbortError") console.warn("Audio play failed:", e);
  });
  // Update MediaSession
  if ("mediaSession" in navigator) {
    navigator.mediaSession.playbackState = "playing";
  }
}
function pauseAudio() { 
  els.audio.pause(); 
  if ("mediaSession" in navigator) {
    navigator.mediaSession.playbackState = "paused";
  }
}

function isActuallyPlaying() {
  const a = els.audio;
  if (!a) return false;
  return !a.paused && !a.ended && (a.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA || a.currentTime > 0);
}
function clearPlayWatchdog() {
  if (state.playWatchdog) {
    clearTimeout(state.playWatchdog);
    state.playWatchdog = null;
  }
}
function schedulePlayWatchdog() {
  clearPlayWatchdog();
  setBuffering(true);
  const seq = ++state.playSeq;
  state.playWatchdog = setTimeout(() => {
    if (state.playSeq !== seq) return;
    if (!isActuallyPlaying()) {
      // Skip to next stream if the current one failed to start in 5s
      console.warn("Stream did not start within 5s; skipping to next.");
      if (state.currentItems.length > 1) {
        playNext();
      } else {
        updatePlayIcon(false);
        setBuffering(false);
      }
    }
  }, 5000);
}

function setBuffering(v) {
  state.buffering = v;
  els.playPauseBtn.classList.toggle("buffering", v);
  if (v) {
    els.playPauseBtn.innerHTML = `<div class="spinner"></div>`;
  } else {
    updatePlayIcon(!els.audio.paused);
  }
  renderMetaLine();
}

function loadAndPlay(url, item) {
  try {
    if (!item) item = { name: "Unknown", url };
    els.audio.pause();
    els.audio.src = "";
    els.audio.src = url || "";
    if (!url) { pauseAudio(); return; }
    startNowPlayingPipeline(item);
    playAudio();
    schedulePlayWatchdog();
  } catch (e) {
    console.error("Audio error:", e);
  }
}

function togglePlayPause() {
  if (!els.audio.src) return;
  els.audio.paused ? playAudio() : pauseAudio();
}
function updatePlayIcon(playing) {
  if (state.buffering) return;
  els.playPauseBtn.innerHTML = icon(playing ? "pause" : "play");
}
function playNext() {
  if (!state.currentItems.length) return;
  const i = (state.currentIndex + 1) % state.currentItems.length;
  state.currentIndex = i;
  const it = state.currentItems[i];
  setNowPlaying(it);
  loadAndPlay(it.url, it);
  refreshActiveStationHighlight();
}
function playPrev() {
  if (!state.currentItems.length) return;
  const i = (state.currentIndex - 1 + state.currentItems.length) % state.currentItems.length;
  state.currentIndex = i;
  const it = state.currentItems[i];
  setNowPlaying(it);
  loadAndPlay(it.url, it);
  refreshActiveStationHighlight();
}
async function shuffle() {
  if (state.currentRoute === "favorites" && state.favorites.length > 0) {
    const i = Math.floor(Math.random() * state.favorites.length);
    playFromList(state.favorites, i);
  } else if (state.currentRoute === "p" && state.currentItems.length > 0) {
    const i = Math.floor(Math.random() * state.currentItems.length);
    playFromList(state.currentItems, i);
  } else if (state.playlistMap.size > 0) {
    const keys = Array.from(state.playlistMap.keys());
    const k = keys[Math.floor(Math.random() * keys.length)];
    state.shuffleTargetSlug = k;
    location.hash = `#/p/${k}`;
  }
}

function onKeydown(e) {
  if (state.currentRoute !== "p" && state.currentRoute !== "favorites") return;
  if (e.key === "ArrowDown" || e.key === "ArrowUp") {
    e.preventDefault();
    const stations = document.querySelectorAll(".station");
    const current = document.activeElement;
    const idx = Array.from(stations).indexOf(current);
    const nextIdx = e.key === "ArrowDown" ? (idx + 1) % stations.length : (idx - 1 + stations.length) % stations.length;
    stations[nextIdx].focus();
  }
}

/* Volume */
function toggleMute() { 
  els.audio.muted = !els.audio.muted; 
  if (!els.audio.muted) {
    applyVolumeCurve(); // Ensure volume is reapplied if unmuting
  }
  updateMuteIcon();
  persistVolume(); 
}

function updateMuteIcon() {
  const muted = els.audio.muted || state.linearVolume === 0;
  els.muteBtn.innerHTML = icon(muted ? "volume-off" : "volume-high");
}

function updateVolumeDisplay() {
  // Update percentage and icon based on linear volume (UI-facing)
  els.volumePercentage.textContent = `${Math.round(state.linearVolume * 100)}%`;
  updateMuteIcon();
}

function applyVolumeCurve() {
  // Apply the quadratic curve to actual audio volume
  const curvedV = Math.pow(state.linearVolume, 2);
  els.audio.volume = curvedV;
  if (state.gainNode && state.audioContext) {
    // Normalization gain is now dynamic; volume curve multiplies it
    // No additional adjustment here to avoid over-boosting
  }
}

function setVolume(linearV) {
  // Clamp and set linear volume (what user perceives/drags)
  state.linearVolume = Math.max(0, Math.min(1, linearV));
  els.volumeRange.value = state.linearVolume;
  applyVolumeCurve();
  updateVolumeDisplay();
  persistVolume();
}

function volumeUp() { 
  const current = state.linearVolume + 0.1;
  setVolume(current); 
}
function volumeDown() { 
  const current = state.linearVolume - 0.1;
  setVolume(current); 
}

/* Errors */
function onAudioError() {
  console.warn("Audio error", els.audio.error);
  clearPlayWatchdog();
  setBuffering(false);
}

/* ===========================
   ROBUST NOW-PLAYING PIPELINE
   ===========================

   Multi-source strategy (highest priority wins):
   5: Timed metadata (HLS ID3 / Icecast with textTracks)
   4: ICY stream metadata (continuous fetch with Icy-MetaData: 1)
   3: Server status endpoints (status-json.xsl, etc.) polled
   2: MediaSession metadata (if browser updates it)
   1: <audio> title attribute (fallback)
*/

function startNowPlayingPipeline(item) {
  const url = item?.url || "";
  const seq = ++state.metaSeq;

  // Reset song + tech meta baselines
  state.currentSong = "";
  state.songPriority = 0;

  // Cleanup previous watchers
  stopNowPlayingWatchers();

  // Tech meta baseline (codec/bitrate/etc)
  updateTechnicalMetaBaseline(url, item, seq);

  // 1) Timed metadata via textTracks (ID3 for HLS or ICY in some browsers)
  bindTimedMetadata(els.audio, seq);

  // 2) Continuous ICY metadata reader (if supported and CORS allows)
  state.npAbort = new AbortController();
  startIcyStreamLoop(url, seq, state.npAbort.signal).catch(() => { /* ignore */ });

  // 3) Poll common server status endpoints for song/title updates
  startStatusPolling(url, seq);

  // 4) Poll MediaSession metadata (low priority)
  startMediaSessionPolling(seq);

  // 5) Fallback from the audio element's title, once
  if (els.audio.title) updateSongTitle(els.audio.title, 1, seq);
}

/* Cleanup all watchers for the previous stream */
function stopNowPlayingWatchers() {
  if (state.npAbort) { try { state.npAbort.abort(); } catch {} state.npAbort = null; }
  if (state.npStatusTimer) { clearInterval(state.npStatusTimer); state.npStatusTimer = null; }
  if (state.npMSessionTimer) { clearInterval(state.npMSessionTimer); state.npMSessionTimer = null; }
}

/* Priority-aware, de-duplicated song setter */
function updateSongTitle(rawTitle, priority, seq) {
  if (state.metaSeq !== seq) return; // stale
  const title = normalizeTitle(rawTitle);
  if (!title) return;

  const changed = title !== state.currentSong;
  const better = priority > (state.songPriority || 0);

  if (better || (changed && priority >= state.songPriority)) {
    state.currentSong = title;
    state.songPriority = priority;
    renderMetaLine();
  }
}

function normalizeTitle(s) {
  if (!s) return "";
  let t = String(s).replace(/\s+/g, " ").trim();

  const bad = /^(offline|unknown|n\/a|no metadata|stream|radio|live|loading)$|^\s*-+\s*$/i; // Added 'loading'
  if (bad.test(t)) return "";

  t = t.replace(/\s*[-–—|•]+\s*$/g, "").trim();

  if (state.streamMeta.stationName) {
    const sn = state.streamMeta.stationName.toLowerCase();
    if (t.toLowerCase() === sn) return "";
  }

  return t;
}

/* Helper: route metadata fetches via proxy (if configured) */
function proxyMeta(url) {
  if (!CONFIG.METADATA_PROXY) return url;
  try {
    new URL(url); // Check if URL is valid before proxying
  } catch {
    return url;
  }
  return `${CONFIG.METADATA_PROXY}?u=${encodeURIComponent(url)}`;
}

/* 1) Timed metadata from textTracks (HLS ID3 cues, etc.) */
function bindTimedMetadata(audio, seq) {
  const tracks = audio.textTracks;
  if (!tracks) return;

  const attach = (track) => {
    if (!track || track.kind !== "metadata") return;
    try { track.mode = "hidden"; } catch {}
    track.oncuechange = () => {
      if (state.metaSeq !== seq) return;
      if (!track.activeCues || track.activeCues.length === 0) return;
      const cue = track.activeCues[track.activeCues.length - 1];
      let text = "";
      if (cue && typeof cue.text === "string" && cue.text) {
        // Try to parse common Icecast/Shoutcast StreamTitle format first
        const m = /StreamTitle=['"]([^'"]+)['"]/.exec(cue.text);
        text = m && m[1] ? m[1] : cue.text;
      }
      if (text) updateSongTitle(text, 5, seq);
    };
  };

  for (let i = 0; i < tracks.length; i++) attach(tracks[i]);
  tracks.addEventListener?.("addtrack", (e) => attach(e.track), { once: false });
}

/* 2) Continuous ICY metadata loop (reads StreamTitle updates as they change) */
async function startIcyStreamLoop(url, seq, signal) {
  if (!url) return;
  try {
    const metaUrl = proxyMeta(url);
    const resp = await fetch(metaUrl, {
      method: "GET",
      mode: "cors",
      cache: "no-store",
      headers: { "Icy-MetaData": "1" },
      signal
    });
    if (!resp || !resp.ok || !resp.body) return;
    const metaint = parseInt(resp.headers.get("icy-metaint") || resp.headers.get("Icy-MetaInt") || "", 10);
    const stationName = resp.headers.get("icy-name") || resp.headers.get("Icy-Name") || "";
    if (stationName) state.streamMeta.stationName = stationName;

    if (!metaint || isNaN(metaint)) return;

    const reader = resp.body.getReader();
    let leftover = new Uint8Array(0);

    const skip = async (len) => {
      if (leftover.length) {
        if (leftover.length >= len) { leftover = leftover.subarray(len); return; }
        len -= leftover.length; leftover = new Uint8Array(0);
      }
      while (len > 0) {
        const { value, done } = await reader.read();
        if (done) return;
        if (!value || !value.length) continue;
        if (value.length <= len) len -= value.length;
        else { leftover = value.subarray(len); len = 0; }
      }
    };
    const readExactly = async (len) => {
      let out = new Uint8Array(len), off = 0;
      if (leftover.length) {
        const n = Math.min(len, leftover.length);
        out.set(leftover.subarray(0, n), 0);
        off += n; leftover = leftover.subarray(n);
      }
      while (off < len) {
        const { value, done } = await reader.read();
        if (done) return null;
        if (!value || !value.length) continue;
        const n = Math.min(len - off, value.length);
        out.set(value.subarray(0, n), off);
        off += n;
        if (n < value.length) leftover = value.subarray(n);
      }
      return out;
    };

    while (!signal.aborted && state.metaSeq === seq) {
      await skip(metaint);
      if (signal.aborted || state.metaSeq !== seq) break;

      const lenByte = await readExactly(1);
      if (!lenByte) break;
      const metaLen = lenByte[0] * 16;
      if (metaLen === 0) continue;

      const metaBuf = await readExactly(metaLen);
      if (!metaBuf) break;

      let meta = "";
      try { meta = new TextDecoder("latin1").decode(metaBuf); }
      catch { try { meta = (new TextDecoder()).decode(metaBuf); } catch {} } // Fallback to UTF-8
      
      const m = /StreamTitle=['"]([^'"]*)['"]/.exec(meta);
      const title = m ? m[1].trim() : "";
      if (title) updateSongTitle(title, 4, seq);
    }
  } catch(e) {
    if (e.name === 'AbortError') { /* Stream loop aborted, ignore */ }
    else { console.warn("ICY stream metadata loop failed:", e); }
  }
}

/* 3) Poll common server endpoints for updates (Icecast/Shoutcast status, custom JSON) */
function startStatusPolling(url, seq) {
  if (!url) return;
  const doPoll = async () => {
    if (state.metaSeq !== seq) return;
    const data = await probeServerStatus(url);
    if (state.metaSeq !== seq || !data) return;
    if (data.title) updateSongTitle(data.title, 3, seq);
    applyTechMeta(data, seq);
  };
  doPoll();
  state.npStatusTimer = setInterval(doPoll, 15000);
}

/* 4) Poll MediaSession metadata for updates (low priority) */
function startMediaSessionPolling(seq) {
  if (!("mediaSession" in navigator)) return;
  const poll = () => {
    if (state.metaSeq !== seq) return;
    const md = navigator.mediaSession.metadata;
    if (!md) return;
    const t = md.title || [md.artist, md.album].filter(Boolean).join(" — ");
    if (t) updateSongTitle(t, 2, seq);
  };
  poll();
  state.npMSessionTimer = setInterval(poll, 5000);
}

/* Technical metadata (codec/bitrate/etc.) */
function updateTechnicalMetaBaseline(url, item, seq) {
  const host = (() => { try { return new URL(url).host; } catch { return ""; } })();
  const codecFromUrl = guessCodecFromUrl(url);
  let br = item?.bitrate ?? item?.br ?? item?.["icy-br"] ?? null;
  if (typeof br === "string") br = parseInt(br, 10);
  let sr = item?.sampleRate ?? item?.samplerate;
  let ch = item?.channels;

  state.streamMeta = {
    host,
    codec: String(item?.codec || item?.format || codecFromUrl || "").toUpperCase(),
    bitrate: (typeof br === "number" && !isNaN(br)) ? br : null,
    sampleRate: (typeof sr === "number" && !isNaN(sr)) ? sr : null,
    channels: (typeof ch === "number" && !isNaN(ch)) ? ch : null,
    genre: item?.genre || "",
    server: "",
    listeners: null,
    stationName: item?.name || state.nowStation?.textContent || ""
  };
  renderMetaLine();

  probeStreamHeaders(url)
    .then(d => { if (state.metaSeq === seq && d) applyTechMeta(d, seq); })
    .finally(() => { if (state.metaSeq === seq) renderMetaLine(); });

  probeServerStatus(url)
    .then(d => { if (state.metaSeq === seq && d) applyTechMeta(d, seq); })
    .finally(() => { if (state.metaSeq === seq) renderMetaLine(); });
}

function applyTechMeta(data, seq) {
  if (state.metaSeq !== seq || !data) return;
  const keys = ["codec","bitrate","sampleRate","channels","genre","server","listeners","stationName","host",
                "description", "website", "peakListeners", "streamHits", "streamUptime", "streamStartTime"];
  for (const k of keys) {
    const v = data[k];
    if (v == null || v === "" || (typeof v === "number" && isNaN(v))) continue;
    state.streamMeta[k] = v;
  }
  renderMetaLine();
}

/* Compact metadata line renderer (song + technicals) */
function formatSampleRate(sr) {
  if (typeof sr !== "number" || isNaN(sr) || sr <= 0) return "";
  if (sr >= 2000) {
    const khz = Math.round(sr / 100) / 10; // one decimal (e.g., 44100 -> 44.1)
    return `${khz} kHz`;
  }
  return `${sr} Hz`;
}

function renderMetaLine() {
  if (!els.nowSong) return;
  const m = state.streamMeta || {};
  const parts = [];

  if (state.currentSong && state.currentSong.trim()) parts.push(state.currentSong.trim());
  else if (state.buffering) parts.push("Loading stream...");

  const codec = (m.codec || "").trim();
  const br = (typeof m.bitrate === "number" && !isNaN(m.bitrate)) ? `${m.bitrate} kbps` : "";
  if (codec && br) parts.push(`${codec} ${br}`);
  else if (codec) parts.push(codec);
  else if (br) parts.push(br);

  const sr = formatSampleRate(m.sampleRate);
  if (sr) parts.push(sr);

  if (typeof m.channels === "number" && !isNaN(m.channels)) {
    parts.push(m.channels === 1 ? "Mono" : m.channels === 2 ? "Stereo" : `${m.channels}ch`);
  }

  if (m.genre) parts.push(m.genre);
  if (typeof m.listeners === "number" && !isNaN(m.listeners)) parts.push(`${m.listeners} listeners`);
  if (m.server) parts.push(m.server);
  if (m.host) parts.push(m.host);
  if (m.website) parts.push(m.website);
  if (m.description) parts.push(m.description);

  const uniq = [];
  const seen = new Set();
  for (const p of parts) {
    const s = String(p).trim();
    if (!s || seen.has(s)) continue;
    seen.add(s);
    uniq.push(s);
  }

  els.nowSong.textContent = uniq.join(" • ");
  if (els.nowMeta) els.nowMeta.textContent = "";
}

/* Active highlight */
function refreshActiveStationHighlight() {
  const nodes = Array.from(document.querySelectorAll(".station"));
  nodes.forEach(n => n.classList.remove("active"));
  if (state.currentIndex >= 0 && state.currentIndex < state.currentItems.length) {
    const cur = state.currentItems[state.currentIndex];
    for (const n of nodes) {
      const name = n.querySelector(".name");
      if (name && cur && name.textContent === (cur.name || "")) {
        n.classList.add("active");
        n.scrollIntoView({ behavior: "smooth", block: "center" });
        break;
      }
    }
  }
}

/* Persistence */
function persistSession() {
  try {
    const data = {
      slug: state.currentSlug,
      index: state.currentIndex,
      station: state.currentItems[state.currentIndex] || null
    };
    // reserved for future use
  } catch(e) { console.error("Failed to persist session:", e); }
}
function restoreLastSession() {}

function persistVolume() {
  try {
    const raw = localStorage.getItem("radio:last");
    const data = raw ? JSON.parse(raw) : {};
    data.linearVolume = state.linearVolume;
    data.muted = els.audio.muted;
    localStorage.setItem("radio:last", JSON.stringify(data));
  } catch(e) { console.error("Failed to persist volume:", e); }
}
function restoreVolume() {
  try {
    const raw = localStorage.getItem("radio:last");
    const data = raw ? JSON.parse(raw) : {};
    if (typeof data.linearVolume === "number") {
      state.linearVolume = Math.max(0, Math.min(1, data.linearVolume));
      els.volumeRange.value = state.linearVolume;
      applyVolumeCurve();
    }
    els.audio.muted = !!data.muted;
    updateVolumeDisplay();
  } catch(e) { console.error("Failed to restore volume:", e); }
}

/* Networking helpers */
async function fetchJson(url) {
  const resp = await fetch(url, { headers: { Accept: "application/json" }, cache: "no-store" });
  if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
  return resp.json();
}

// Modified to use proxyMeta for all external JSON fetches
async function fetchJsonWithProxy(url, ms = 4500) {
  const proxiedUrl = proxyMeta(url);
  const resp = await fetchWithTimeout(proxiedUrl, { headers: { Accept: "application/json" }, mode: "cors", cache: "no-store" }, ms);
  if (resp && resp.ok) {
    try { return await resp.json(); } catch(e) { console.warn(`Failed to parse JSON from ${url}:`, e); return null; }
  }
  return null;
}

async function fetchFirstOkJson(list) {
  let lastErr = null;
  for (const u of list) {
    try {
      // Use direct fetchJson for internal index/playlist JSON, proxy for external if configured
      const data = (/^https?:\/\//i.test(u) && CONFIG.METADATA_PROXY && !u.startsWith(location.origin)) ? await fetchJsonWithProxy(u) : await fetchJson(u);
      return { url: u, data };
    } catch (e) { lastErr = e; }
  }
  if (lastErr) { lastErr.__lastTried = list[list.length - 1]; throw lastErr; }
  throw new Error("All candidate URLs failed");
}


/* Utils */
function escapeHtml(s) {
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function debounce(fn, ms=100) {
  let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(null, args), ms); };
}
function toLocalTime(v) { try { return new Date(v).toLocaleString(); } catch { return v; } }
function unique(arr) { return Array.from(new Set(arr.filter(Boolean))); }

/* Icon helper */
function icon(name, size = 20, cls = "icon") {
  return `<svg class="${cls}" width="${size}" height="${size}" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><use href="#i-${name}" xlink:href="#i-${name}"></use></svg>`;
}

/* Tech meta probes and parsers */
function guessCodecFromUrl(u) {
  try {
    const p = new URL(u).pathname.toLowerCase();
    if (p.endsWith(".m3u8")) return "HLS";
    if (p.endsWith(".aac") || p.endsWith(".aacp")) return "AAC";
    if (p.endsWith(".mp3")) return "MP3";
    if (p.endsWith(".ogg") || p.endsWith(".oga")) return "OGG";
    if (p.endsWith(".opus")) return "OPUS";
    if (p.endsWith(".flac")) return "FLAC";
  } catch(e) { console.warn("Error guessing codec from URL:", e); }
  return "";
}
function mapContentTypeToCodec(ct) {
  const t = (ct || "").toLowerCase();
  return t.includes("aac") ? "AAC"
       : t.includes("mpeg") ? "MP3"
       : t.includes("ogg") ? "OGG"
       : t.includes("opus") ? "OPUS"
       : t.includes("flac") ? "FLAC"
       : (t.includes("x-mpegurl") || t.includes("vnd.apple.mpegurl")) ? "HLS"
       : "";
}
function parseIceAudioInfo(s) {
  const out = {};
  String(s || "").split(/[;,]/).forEach(part => {
    const [k, v] = part.split("=");
    if (k && v) out[k.trim().toLowerCase()] = v.trim();
  });
  return out;
}

async function fetchWithTimeout(url, init = {}, ms = 4000) {
  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), ms);
  try {
    const resp = await fetch(url, { ...init, signal: ctrl.signal });
    clearTimeout(timer);
    return resp;
  } catch(e) {
    if (e.name === 'AbortError') console.debug(`Fetch timed out for ${url}`);
    else console.warn(`Fetch error for ${url}:`, e);
    clearTimeout(timer);
    return null;
  }
}

async function probeStreamHeaders(url) {
  if (!url) return null;
  const headUrl = proxyMeta(url); // Use proxy for HEAD/GET requests
  const req = async method => await fetchWithTimeout(headUrl, {
    method,
    mode: "cors",
    cache: "no-store",
    redirect: "follow",
    headers: { "Icy-MetaData": "1", ...(method === "GET" ? { Range: "bytes=0-1" } : {}) }
  }, 3500);

  let resp = await req("HEAD");
  if ((!resp || !resp.ok) && (resp = await req("GET")), !resp || !resp.ok) return null;

  const h = resp.headers;
  const data = {};
  const ct = h.get("content-type") || h.get("Content-Type") || "";
  data.codec = mapContentTypeToCodec(ct) || "";
  data.server = (h.get("server") || h.get("Server") || "")?.split("/")[0]?.trim() || "";
  if (data.server === "Icecast" && ct.includes("mpegurl")) {
    data.codec = "HLS"; // Sometimes Icecast serves HLS but advertises itself as Icecast
  }

  const icyName = h.get("icy-name") || h.get("Icy-Name");
  if (icyName) data.stationName = icyName;

  const icyGenre = h.get("icy-genre") || h.get("Icy-Genre");
  if (icyGenre) data.genre = icyGenre;

  const icyBr = h.get("icy-br") || h.get("Icy-Br");
  if (icyBr) {
    const n = parseInt(icyBr, 10);
    if (!isNaN(n)) data.bitrate = n;
  }

  const iceInfo = h.get("ice-audio-info") || h.get("Ice-Audio-Info") || "";
  if (iceInfo) {
    const m = parseIceAudioInfo(iceInfo);
    if (m.bitrate) { const n = parseInt(m.bitrate, 10); if (!isNaN(n)) data.bitrate = n; }
    if (m.samplerate) { const n = parseInt(m.samplerate, 10); if (!isNaN(n)) data.sampleRate = n; }
    if (m.channels) { const n = parseInt(m.channels, 10); if (!isNaN(n)) data.channels = n; }
  }
  return data;
}

async function probeServerStatus(url) {
  let u;
  try { u = new URL(url); } catch { return null; }
  const origin = u.origin;
  const path = u.pathname || "";

  const mk = (p) => `${origin}${p}`; // Use directly if not proxying, else proxyMeta will wrap it
  const candidates = unique([
    mk(`/status-json.xsl?mount=${encodeURIComponent(path)}`),
    mk(`/status-json.xsl`),
    mk(`/status.xsl?json=1`),
    mk(`/stats?json=1`),
    mk(`/stats?sid=1&json=1`),
    mk(`/stats?sid=2&json=1`),
    mk(`/stats?sid=3&json=1`),
    mk(`/statistics?json=1`),
    mk(`/json.xsl`),
    mk(`/radio/json`), // Common for some modern radio platforms
    mk(`/streaminfo`),  // Another common API endpoint
    mk(`/api/v1/stream/current`), // Example for some specific APIs
    mk(path.replace(/\.[a-z0-9]+$/i, '') + '/status.json'), // e.g. /stream.mp3 -> /stream/status.json
  ]);

  for (const c of candidates) {
    const json = await fetchJsonWithProxy(c, 4500); // All status fetches go through proxy
    if (!json) continue;
    const parsed = parseServerStatus(json, u);
    if (parsed) return parsed;
  }

  // Also try to parse HLS manifests if applicable for more metadata (like ID3 tags/stream info)
  if (guessCodecFromUrl(url) === 'HLS') {
    const hlsMeta = await probeHlsManifest(url);
    if (hlsMeta) return hlsMeta;
  }

  return null;
}

// New function to probe HLS manifest for metadata
async function probeHlsManifest(hlsUrl) {
  const proxiedHlsUrl = proxyMeta(hlsUrl);
  try {
    const resp = await fetchWithTimeout(proxiedHlsUrl, { cache: 'no-store' }, 5000);
    if (!resp || !resp.ok) return null;
    const manifest = await resp.text();

    const data = {};
    const audioRegex = /TYPE=AUDIO.*URI="([^"]+)"/;
    const streamInfoRegex = /RESOLUTION=(\d+x\d+).*BANDWIDTH=(\d+)/;
    const titleRegex = /#EXTINF:\d+,(.*)/; // Basic title extraction if manifest has it

    // Extract Audio-only URI if present (often contains more specific stream metadata)
    const audioMatch = manifest.match(audioRegex);
    if (audioMatch && audioMatch[1]) {
      data.hlsAudioUri = audioMatch[1];
    }

    // Extract general stream info if available
    const streamMatch = manifest.match(streamInfoRegex);
    if (streamMatch && streamMatch[2]) {
      const bitrate = Math.round(parseInt(streamMatch[2], 10) / 1000);
      if (!isNaN(bitrate)) data.bitrate = bitrate;
    }

    const titleMatch = manifest.match(titleRegex);
    if (titleMatch && titleMatch[1]) {
      data.title = titleMatch[1].trim();
    }

    data.codec = data.codec || "HLS";

    return Object.keys(data).length > 0 ? data : null;
  } catch (e) {
    console.warn("Failed to probe HLS manifest:", e);
    return null;
  }
}


function parseServerStatus(json, u) {
  // --- Icecast/Shoutcast specific parsing ---
  if (json.icestats) {
    const ic = json.icestats;
    const srcs = Array.isArray(ic.source) ? ic.source : (ic.source ? [ic.source] : []);
    const mount = u?.pathname || "";
    let src = srcs[0] || null;
    if (mount && srcs.length > 1) {
      const exact = srcs.find(s => { try { return s.listenurl && new URL(s.listenurl).pathname === mount; } catch { return false; } });
      src = exact || srcs.find(s => String(s.listenurl || "").includes(mount)) || src;
    }
    if (!src) return null;

    const out = {};
    const ai = src.audio_info || src["ice-audio-info"] || "";
    const parsed = parseIceAudioInfo(ai);

    if (src.bitrate) { const n = parseInt(src.bitrate, 10); if (!isNaN(n)) out.bitrate = n; }
    if (parsed.bitrate) { const n = parseInt(parsed.bitrate, 10); if (!isNaN(n)) out.bitrate = n; }
    if (parsed.samplerate) { const n = parseInt(parsed.samplerate, 10); if (!isNaN(n)) out.sampleRate = n; }
    if (parsed.channels) { const n = parseInt(parsed.channels, 10); if (!isNaN(n)) out.channels = n; }
    if (src.genre) out.genre = src.genre;
    if (src.listeners != null) { const n = parseInt(src.listeners, 10); if (!isNaN(n)) out.listeners = n; }
    if (src.server_name) out.stationName = src.server_name;
    if (src.server_type) out.codec = out.codec || mapContentTypeToCodec(String(src.server_type));
    if (src.title) out.title = src.title;
    if (src.description) out.description = src.description; // Added description
    if (src.url) out.streamUrl = src.url; // Added stream URL from status
    if (src.stream_start_iso8601) out.streamStartTime = src.stream_start_iso8601; // Added stream start time

    return out;
  }

  // --- Shoutcast v1/v2 style parsing (often less structured) ---
  if (json.streams || json.songtitle || json.currentlisteners != null) {
    let src = null;
    if (json.streams) {
      let s = json.streams.stream || json.streams;
      if (Array.isArray(s)) src = s[0];
      else if (typeof s === "object") src = s;
    } else {
      src = json;
    }

    const out = {};
    if (src) {
      if (src.bitrate) { const n = parseInt(src.bitrate, 10); if (!isNaN(n)) out.bitrate = n; }
      if (src.currentlisteners != null) { const n = parseInt(src.currentlisteners, 10); if (!isNaN(n)) out.listeners = n; }
      if (src.peaklisteners != null) { const n = parseInt(src.peaklisteners, 10); if (!isNaN(n)) out.peakListeners = n; } // Added peak listeners
      if (src.servergenre) out.genre = src.servergenre;
      if (src.servertitle) out.stationName = src.servertitle;
      if (src.songtitle) out.title = src.songtitle;
      if (src.contenttype) out.codec = mapContentTypeToCodec(String(src.contenttype));
      if (src.streamhits != null) out.streamHits = src.streamhits; // Added stream hits
      if (src.streamuptime) out.streamUptime = src.streamuptime; // Added stream uptime
    }
    return out;
  }

  // --- More generic JSON parsing, looking for common keys ---
  const findValue = (obj, keys, isNum = false) => {
    if (!obj) return null;
    for (const key of keys) {
      const val = obj[key];
      if (val != null) {
        if (isNum) {
          const n = parseInt(val, 10);
          return !isNaN(n) ? n : null;
        }
        return String(val);
      }
    }
    return null;
  };

  const out = {};
  out.title = findValue(json, ['title', 'song', 'current_song', 'now_playing', 'track']);
  out.artist = findValue(json, ['artist', 'current_artist']);
  if (!out.title && out.artist && findValue(json, ['album'])) { // Construct title if only artist and album
      out.title = `${out.artist} - ${findValue(json, ['album'])}`;
  } else if (!out.title && out.artist && findValue(json, ['song'])) { // Construct title if only artist and song
      out.title = `${out.artist} - ${findValue(json, ['song'])}`;
  }

  out.stationName = findValue(json, ['station_name', 'name', 'radio_name', 'stream_name']);
  out.listeners = findValue(json, ['listeners', 'current_listeners', 'clients'], true);
  out.bitrate = findValue(json, ['bitrate', 'kbps'], true);
  out.genre = findValue(json, ['genre', 'categories']);
  out.server = findValue(json, ['server_software', 'server']);
  out.codec = mapContentTypeToCodec(findValue(json, ['content_type', 'format'])) || findValue(json, ['codec']);
  out.description = findValue(json, ['description', 'about']);
  out.website = findValue(json, ['website', 'homepage', 'url']);

  // If a generic title was found, prioritize it.
  if (out.title) {
      // If we found an artist separately, combine them
      if (out.artist && !out.title.toLowerCase().includes(out.artist.toLowerCase())) {
          out.title = `${out.artist} - ${out.title}`;
      }
      return out;
  }

  return null;
}

function saveFavorites() {
  localStorage.setItem("radio:favorites", JSON.stringify(state.favorites));
}

function loadFavorites() {
  try {
    const raw = localStorage.getItem("radio:favorites");
    state.favorites = raw ? JSON.parse(raw) : [];
  } catch(e) {
    state.favorites = [];
  }
}
</script>
</html>
